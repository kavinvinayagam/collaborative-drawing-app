<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Real-Time Collaborative Drawing Canvas</title>
    <style>
        :root {
            --primary-color: #3498db;
            --danger-color: #e74c3c;
            --success-color: #2ecc71;
            --bg-dark: #2c3e50;
            --bg-light: #ecf0f1;
            --text-dark: #2c3e50;
            --border-color: #bdc3c7;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg-light);
            overflow: hidden;
        }

        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        /* Header */
        .header {
            background: var(--bg-dark);
            color: white;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .header h1 {
            font-size: 20px;
            font-weight: 600;
        }

        .connection-status {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--danger-color);
            animation: pulse 2s infinite;
        }

        .status-indicator.connected {
            background: var(--success-color);
            animation: none;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Toolbar */
        .toolbar {
            background: white;
            padding: 15px 20px;
            display: flex;
            gap: 20px;
            align-items: center;
            border-bottom: 2px solid var(--border-color);
            flex-wrap: wrap;
        }

        .tool-group {
            display: flex;
            gap: 10px;
            align-items: center;
            padding-right: 20px;
            border-right: 1px solid var(--border-color);
        }

        .tool-group:last-child {
            border-right: none;
        }

        .tool-group label {
            font-weight: 600;
            color: var(--text-dark);
            font-size: 14px;
        }

        .tool-btn {
            padding: 8px 16px;
            border: 2px solid var(--border-color);
            background: white;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s;
        }

        .tool-btn:hover {
            background: var(--bg-light);
            transform: translateY(-2px);
        }

        .tool-btn.active {
            background: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }

        .color-picker-wrapper {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .color-preview {
            width: 35px;
            height: 35px;
            border: 2px solid var(--border-color);
            border-radius: 6px;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .color-preview:hover {
            transform: scale(1.1);
        }

        #colorPicker {
            width: 60px;
            height: 35px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
        }

        #strokeWidth {
            width: 120px;
            cursor: pointer;
        }

        .stroke-value {
            font-weight: 600;
            color: var(--primary-color);
            min-width: 30px;
        }

        /* Main Content */
        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        /* Canvas Area */
        .canvas-container {
            flex: 1;
            position: relative;
            background: white;
            overflow: hidden;
        }

        #drawingCanvas {
            cursor: crosshair;
            display: block;
        }

        /* Cursor indicators for other users */
        .remote-cursor {
            position: absolute;
            pointer-events: none;
            z-index: 1000;
            transition: all 0.05s linear;
        }

        .cursor-pointer {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }

        .cursor-label {
            position: absolute;
            top: 25px;
            left: 25px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
        }

        /* Sidebar */
        .sidebar {
            width: 280px;
            background: white;
            border-left: 2px solid var(--border-color);
            display: flex;
            flex-direction: column;
        }

        .sidebar-section {
            padding: 20px;
            border-bottom: 2px solid var(--border-color);
        }

        .sidebar-section h3 {
            font-size: 16px;
            margin-bottom: 15px;
            color: var(--text-dark);
        }

        .user-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .user-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: var(--bg-light);
            border-radius: 6px;
        }

        .user-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .user-name {
            flex: 1;
            font-weight: 500;
            font-size: 14px;
        }

        .user-badge {
            background: var(--success-color);
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 11px;
            font-weight: 600;
        }

        /* History Controls */
        .history-controls {
            display: flex;
            gap: 10px;
        }

        .history-btn {
            flex: 1;
            padding: 10px;
            border: 2px solid var(--border-color);
            background: white;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
        }

        .history-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .history-btn:not(:disabled):hover {
            background: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }

        .clear-btn {
            width: 100%;
            padding: 12px;
            border: 2px solid var(--danger-color);
            background: white;
            color: var(--danger-color);
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            margin-top: 10px;
            transition: all 0.2s;
        }

        .clear-btn:hover {
            background: var(--danger-color);
            color: white;
        }

        /* Stats */
        .stats {
            flex: 1;
            overflow-y: auto;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid var(--border-color);
        }

        .stat-label {
            font-size: 13px;
            color: #7f8c8d;
        }

        .stat-value {
            font-weight: 600;
            color: var(--text-dark);
        }

        /* Responsive */
        @media (max-width: 768px) {
            .sidebar {
                display: none;
            }

            .toolbar {
                gap: 10px;
            }

            .tool-group {
                padding-right: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Header -->
        <div class="header">
            <h1>üé® Real-Time Collaborative Canvas</h1>
            <div class="connection-status">
                <span class="status-indicator" id="statusIndicator"></span>
                <span id="statusText">Connecting...</span>
            </div>
        </div>

        <!-- Toolbar -->
        <div class="toolbar">
            <!-- Tool Selection -->
            <div class="tool-group">
                <label>Tool:</label>
                <button class="tool-btn active" id="brushBtn" data-tool="brush">üñåÔ∏è Brush</button>
                <button class="tool-btn" id="eraserBtn" data-tool="eraser">üßπ Eraser</button>
            </div>

            <!-- Color Selection -->
            <div class="tool-group">
                <label>Color:</label>
                <div class="color-picker-wrapper">
                    <div class="color-preview" id="colorPreview" style="background: #000000;"></div>
                    <input type="color" id="colorPicker" value="#000000">
                </div>
            </div>

            <!-- Stroke Width -->
            <div class="tool-group">
                <label>Width:</label>
                <input type="range" id="strokeWidth" min="1" max="50" value="5">
                <span class="stroke-value" id="strokeValue">5px</span>
            </div>

            <!-- History Controls -->
            <div class="tool-group">
                <button class="tool-btn" id="undoBtn" disabled>‚Ü∂ Undo</button>
                <button class="tool-btn" id="redoBtn" disabled>‚Ü∑ Redo</button>
            </div>
        </div>

        <!-- Main Content -->
        <div class="main-content">
            <!-- Canvas Area -->
            <div class="canvas-container" id="canvasContainer">
                <canvas id="drawingCanvas"></canvas>
                <!-- Remote cursors will be added here dynamically -->
            </div>

            <!-- Sidebar -->
            <div class="sidebar">
                <!-- Online Users -->
                <div class="sidebar-section">
                    <h3>üë• Online Users (<span id="userCount">0</span>)</h3>
                    <div class="user-list" id="userList">
                        <!-- Users will be added dynamically -->
                    </div>
                </div>

                <!-- History & Clear -->
                <div class="sidebar-section">
                    <h3>üïê History</h3>
                    <div class="history-controls">
                        <button class="history-btn" id="sidebarUndo" disabled>Undo</button>
                        <button class="history-btn" id="sidebarRedo" disabled>Redo</button>
                    </div>
                    <button class="clear-btn" id="clearBtn">üóëÔ∏è Clear Canvas</button>
                </div>

                <!-- Statistics -->
                <div class="sidebar-section stats">
                    <h3>üìä Statistics</h3>
                    <div class="stat-item">
                        <span class="stat-label">Operations:</span>
                        <span class="stat-value" id="operationCount">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Undo Stack:</span>
                        <span class="stat-value" id="undoCount">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Redo Stack:</span>
                        <span class="stat-value" id="redoCount">0</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

   <script>
    // ============================================
    // CANVAS MANAGER (No change needed here)
    // ============================================
    class CanvasManager {
        constructor(canvasId) {
            this.canvas = document.getElementById(canvasId);
            this.ctx = this.canvas.getContext('2d');
            this.isDrawing = false;
            this.currentTool = 'brush';
            this.currentColor = '#000000';
            this.strokeWidth = 5;
            
            this.lastX = 0;
            this.lastY = 0;
            
            this.setupCanvas();
            this.attachEventListeners();
        }

        setupCanvas() {
            this.resizeCanvas();
            window.addEventListener('resize', () => this.resizeCanvas());
        }

        resizeCanvas() {
            const container = this.canvas.parentElement;
            this.canvas.width = container.clientWidth;
            this.canvas.height = container.clientHeight;
            
            if (window.app && window.app.historyManager) {
                window.app.historyManager.redrawCanvas();
            }
        }

        attachEventListeners() {
            // Mouse and Touch Event handlers remain here and are correct.
            this.canvas.addEventListener('mousedown', (e) => this.startDrawing(e));
            this.canvas.addEventListener('mousemove', (e) => this.draw(e));
            this.canvas.addEventListener('mouseup', () => this.stopDrawing());
            this.canvas.addEventListener('mouseout', () => this.stopDrawing());

            this.canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                this.canvas.dispatchEvent(new MouseEvent('mousedown', { clientX: touch.clientX, clientY: touch.clientY }));
            });
            this.canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                this.canvas.dispatchEvent(new MouseEvent('mousemove', { clientX: touch.clientX, clientY: touch.clientY }));
            });
            this.canvas.addEventListener('touchend', (e) => {
                e.preventDefault();
                this.canvas.dispatchEvent(new MouseEvent('mouseup', {}));
            });
        }

        getMousePos(e) {
            const rect = this.canvas.getBoundingClientRect();
            return {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
        }

        startDrawing(e) {
            this.isDrawing = true;
            const pos = this.getMousePos(e);
            this.lastX = pos.x;
            this.lastY = pos.y;
        }

        draw(e) {
            if (!this.isDrawing) return;

            const pos = this.getMousePos(e);
            
            const operation = {
                type: 'draw',
                tool: this.currentTool,
                color: this.currentColor,
                width: this.strokeWidth,
                startX: this.lastX,
                startY: this.lastY,
                endX: pos.x,
                endY: pos.y,
                timestamp: Date.now(),
                opId: `${window.app.wsClient.userId}-${Date.now()}` 
            };

            // Draw locally immediately
            this.drawOperation(operation);

            // Send to server
            if (window.app && window.app.wsClient) {
                window.app.wsClient.sendOperation(operation);
            }

            // Important: Local users must still push their line to their own history immediately 
            // so Undo/Redo tracking can start right away and the server can sync.
            if (window.app && window.app.historyManager) {
                window.app.historyManager.addLocalOperation(operation);
            }

            this.lastX = pos.x;
            this.lastY = pos.y;

            if (window.app && window.app.wsClient) {
                window.app.wsClient.sendCursorPosition(pos.x, pos.y);
            }
        }

        stopDrawing() {
            this.isDrawing = false;
        }

        drawOperation(operation) {
            this.ctx.beginPath();
            this.ctx.moveTo(operation.startX, operation.startY);
            this.ctx.lineTo(operation.endX, operation.endY);
            
            if (operation.tool === 'eraser') {
                this.ctx.globalCompositeOperation = 'destination-out';
                this.ctx.strokeStyle = 'rgba(0,0,0,1)';
            } else {
                this.ctx.globalCompositeOperation = 'source-over';
                this.ctx.strokeStyle = operation.color;
            }
            
            this.ctx.lineWidth = operation.width;
            this.ctx.lineCap = 'round';
            this.ctx.lineJoin = 'round';
            this.ctx.stroke();
        }

        clear() {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        }
        
        // ... (Tool setters remain) ...
        setTool(tool) { this.currentTool = tool; }
        setColor(color) { this.currentColor = color; }
        setStrokeWidth(width) { this.strokeWidth = width; }
    }

    // ============================================
    // HISTORY MANAGER (Undo/Redo) - LOGIC CONFIRMED CORRECT
    // ============================================
    class HistoryManager {
        constructor(canvasManager) {
            this.canvasManager = canvasManager;
            this.operations = []; 
            this.currentIndex = -1; 
        }

        // Used by local user after drawing to initialize history for undo/redo tracking
        addLocalOperation(operation) {
            this.operations.splice(this.currentIndex + 1, this.operations.length);
            this.operations.push(operation);
            this.currentIndex = this.operations.length - 1;
            this.updateUI();
        }

        // Used on initial connection
        loadHistory(operations) {
            this.operations = operations;
            this.currentIndex = this.operations.length - 1;
            this.redrawCanvas();
            this.updateUI();
        }

        // Remote draw operations now ONLY rely on the draw command + the following historyUpdate!
        // This function is kept simple as it's not strictly necessary due to historyUpdate, 
        // but it can help if there's latency between the draw and historyUpdate messages.
        receiveRemoteOperation(operation) {
             // Simply draw the operation, but do NOT manipulate this.operations or this.currentIndex here.
             // The full state synchronization (history array length) is handled by receiveHistoryUpdate.
             this.canvasManager.drawOperation(operation);
        }

        undo() {
            if (this.currentIndex < 0) return;
            if (window.app && window.app.wsClient) {
                window.app.wsClient.sendUndo();
            }
            // Optimistic update for responsiveness
            this.currentIndex--;
            this.redrawCanvas();
            this.updateUI();
        }


        redo() {
            if (this.currentIndex >= this.operations.length - 1) return;
            
            if (window.app && window.app.wsClient) {
                window.app.wsClient.sendRedo();
            }
            
            // Optimistic update for responsiveness
            this.currentIndex++;
            this.redrawCanvas();
            this.updateUI();
        }

        // The synchronization anchor: updates full array and index from server
        receiveHistoryUpdate(newHistory) {
            // Replaces the *active* part of the history with what the server says is the new full history.
            this.operations = newHistory; 
            this.currentIndex = newHistory.length - 1; 
            this.redrawCanvas();
            this.updateUI();
        }

        redrawCanvas() {
            this.canvasManager.clear();
            for (let i = 0; i <= this.currentIndex; i++) {
                this.canvasManager.drawOperation(this.operations[i]);
            }
        }

        clear() {
            this.operations = [];
            this.currentIndex = -1;
            this.canvasManager.clear();
            this.updateUI();
        }

        updateUI() {
            const totalOperations = this.operations.length;
            
            const canUndo = this.currentIndex >= 0;
            // CORRECT REDO LOGIC: Enabled if the pointer is not pointing to the last item in the full array.
            const canRedo = this.currentIndex < totalOperations - 1;
            
            // Enable/Disable Buttons
            document.getElementById('undoBtn').disabled = !canUndo;
            document.getElementById('redoBtn').disabled = !canRedo;
            document.getElementById('sidebarUndo').disabled = !canUndo;
            document.getElementById('sidebarRedo').disabled = !canRedo;
            
            // Update stats
            document.getElementById('operationCount').textContent = totalOperations;
            document.getElementById('undoCount').textContent = this.currentIndex + 1;
            document.getElementById('redoCount').textContent = totalOperations - (this.currentIndex + 1);
        }
    }

    // ============================================
    // WEBSOCKET CLIENT (No change needed here)
    // ============================================
    class WebSocketClient {
        constructor() {
            this.ws = null;
            this.connected = false;
            this.userId = null;
            this.userColor = null;
            this.reconnectInterval = 3000;
        }

        connect() {
            const wsUrl = 'wss://collaborative-drawing-app-ba9a.onrender.com';

            
            try {
                this.ws = new WebSocket(wsUrl);
                
                this.ws.onopen = () => {
                    console.log('WebSocket connected');
                    this.connected = true;
                    this.updateConnectionStatus(true);
                };

                this.ws.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    this.handleMessage(data);
                };

                this.ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    this.updateConnectionStatus(false);
                };

                this.ws.onclose = () => {
                    console.log('WebSocket disconnected');
                    this.connected = false;
                    this.updateConnectionStatus(false);
                    setTimeout(() => this.connect(), this.reconnectInterval);
                };
            } catch (error) {
                console.error('Failed to connect:', error);
                this.updateConnectionStatus(false);
                setTimeout(() => this.connect(), this.reconnectInterval);
            }
        }

        
        handleMessage(data) {
            switch (data.type) {
                case 'init':
                    this.userId = data.userId;
                    this.userColor = data.color;
                    break;

                case 'history':
                    if (window.app && window.app.historyManager) {
                        window.app.historyManager.loadHistory(data.operations);
                    }
                    break;
                
                case 'draw':
                    if (window.app && window.app.historyManager) {
                         // Only draw the line, history state update is handled by 'historyUpdate'
                        window.app.historyManager.receiveRemoteOperation(data.operation);
                    }
                    break;
                
                // This is the single source of truth for history and undo/redo button states
                case 'historyUpdate': 
                    if (window.app && window.app.historyManager) {
                        window.app.historyManager.receiveHistoryUpdate(data.operations);
                    }
                    break;

                case 'userJoined':
                    this.addUser(data.user);
                    break;
                case 'userLeft':
                    this.removeUser(data.userId);
                    break;
                case 'usersList':
                    this.updateUsersList(data.users);
                    break;
                case 'cursor':
                    this.updateRemoteCursor(data.userId, data.x, data.y, data.userName, data.color);
                    break;
                case 'clear':
                    if (window.app && window.app.historyManager) {
                        window.app.historyManager.clear();
                    }
                    break;
            }
        }

        // ... (sendOperation, sendUndo, sendRedo, sendClear functions remain the same) ...
        sendOperation(operation) {
            if (this.connected && this.ws.readyState === WebSocket.OPEN) {
                this.ws.send(JSON.stringify({ type: 'draw', operation: operation }));
            }
        }
        sendCursorPosition(x, y) {
            if (this.connected && this.ws.readyState === WebSocket.OPEN) {
                this.ws.send(JSON.stringify({ type: 'cursor', x: x, y: y }));
            }
        }
        sendUndo() {
            if (this.connected && this.ws.readyState === WebSocket.OPEN) {
                this.ws.send(JSON.stringify({ type: 'undo' }));
            }
        }
        sendRedo() {
            if (this.connected && this.ws.readyState === WebSocket.OPEN) {
                this.ws.send(JSON.stringify({ type: 'redo' }));
            }
        }
        sendClear() {
            if (this.connected && this.ws.readyState === WebSocket.OPEN) {
                this.ws.send(JSON.stringify({ type: 'clear' }));
            }
        }
        
        // ... (updateConnectionStatus, addUser, removeUser, etc. functions remain the same) ...
        updateConnectionStatus(connected) {
            const indicator = document.getElementById('statusIndicator');
            const statusText = document.getElementById('statusText');
            
            if (connected) {
                indicator.classList.add('connected');
                statusText.textContent = 'Connected';
            } else {
                indicator.classList.remove('connected');
                statusText.textContent = 'Disconnected';
            }
        }

        addUser(user) {
            const userList = document.getElementById('userList');
            if (document.getElementById(`user-${user.id}`)) return; 

            const userItem = document.createElement('div');
            userItem.className = 'user-item';
            userItem.id = `user-${user.id}`;
            const isMe = user.id === this.userId;
            userItem.innerHTML = `
                <div class="user-color" style="background: ${user.color};"></div>
                <span class="user-name">${user.name}${isMe ? ' (You)' : ''}</span>
                <span class="user-badge">${isMe ? 'Me' : 'Online'}</span>
            `;
            userList.appendChild(userItem);
            this.updateUserCount();
        }

        removeUser(userId) {
            const userItem = document.getElementById(`user-${userId}`);
            if (userItem) {
                userItem.remove();
            }
            
            const cursor = document.getElementById(`cursor-${userId}`);
            if (cursor) {
                cursor.remove();
            }
            
            this.updateUserCount();
        }

        updateUsersList(users) {
            const userList = document.getElementById('userList');
            userList.innerHTML = '';
            
            users.forEach(user => {
                this.addUser(user);
            });
        }

        updateUserCount() {
            const userList = document.getElementById('userList');
            const count = userList.children.length;
            document.getElementById('userCount').textContent = count;
        }

        updateRemoteCursor(userId, x, y, userName, color) {
            if (userId === this.userId) return; 

            const container = document.getElementById('canvasContainer');
            let cursor = document.getElementById(`cursor-${userId}`);
            
            if (!cursor) {
                cursor = document.createElement('div');
                cursor.id = `cursor-${userId}`;
                cursor.className = 'remote-cursor';
                cursor.innerHTML = `
                    <div class="cursor-pointer" style="background: ${color};"></div>
                    <div class="cursor-label">${userName}</div>
                `;
                container.appendChild(cursor);
            }
            
            cursor.style.left = `${x}px`;
            cursor.style.top = `${y}px`;
        }
    }

    // ============================================
    // MAIN APPLICATION 
    // ============================================
    class CollaborativeCanvasApp {
        constructor() {
            this.canvasManager = new CanvasManager('drawingCanvas');
            this.historyManager = new HistoryManager(this.canvasManager);
            this.wsClient = new WebSocketClient();
            
            this.setupUI();
            this.wsClient.connect();
        }

        setupUI() {
            // ... (rest of the UI setup code remains the same) ...
            
            document.querySelectorAll('.tool-btn[data-tool]').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    document.querySelectorAll('.tool-btn[data-tool]').forEach(b => b.classList.remove('active'));
                    e.target.classList.add('active');
                    this.canvasManager.setTool(e.target.dataset.tool);
                });
            });

            const colorPicker = document.getElementById('colorPicker');
            const colorPreview = document.getElementById('colorPreview');
            
            colorPicker.addEventListener('input', (e) => {
                const color = e.target.value;
                colorPreview.style.background = color;
                this.canvasManager.setColor(color);
            });

            colorPreview.addEventListener('click', () => {
                colorPicker.click();
            });

            const strokeWidth = document.getElementById('strokeWidth');
            const strokeValue = document.getElementById('strokeValue');
            
            strokeWidth.addEventListener('input', (e) => {
                const width = e.target.value;
                strokeValue.textContent = `${width}px`;
                this.canvasManager.setStrokeWidth(parseInt(width));
            });

            document.getElementById('undoBtn').addEventListener('click', () => { this.historyManager.undo(); });
            document.getElementById('redoBtn').addEventListener('click', () => { this.historyManager.redo(); });
            document.getElementById('sidebarUndo').addEventListener('click', () => { this.historyManager.undo(); });
            document.getElementById('sidebarRedo').addEventListener('click', () => { this.historyManager.redo(); });

            document.getElementById('clearBtn').addEventListener('click', () => {
                if (confirm('Are you sure you want to clear the entire canvas? This will affect all users.')) {
                    this.historyManager.clear(); 
                    this.wsClient.sendClear(); 
                }
            });

            document.addEventListener('keydown', (e) => {
                if (e.ctrlKey || e.metaKey) {
                    if (e.key === 'z' && !e.shiftKey) {
                        e.preventDefault();
                        this.historyManager.undo();
                    } else if (e.key === 'z' && e.shiftKey || e.key === 'y') {
                        e.preventDefault();
                        this.historyManager.redo();
                    }
                }
            });
        }
    }

    window.app = null;
    document.addEventListener('DOMContentLoaded', () => {
        window.app = new CollaborativeCanvasApp();
    });
</script>
</body>
</html>
